# 数据库范式

人们发现有些关系模式存在插入、删除、更新异常、数据冗余等弊病，人们寻求解决这些问题的方法，这就是规范化的目的。

*注：更新异常实际是数据冗余导致的必须多次更新问题*
 

规范化的基本思想是逐步消除数据依赖中不合适的部分，使关系数据库模式的各关系模式达到某种程度的“分离”，即“一事一地”的模式设计原则。各种范式呈递次规范，越高的范式数据库冗余越小。对一种数据的操作对整体数据的影响越小。

**也就是说范式是将合并了的数据表拆分出来**,如果存在多表合并在一表中的情况就会产生数据的相互依赖,互相限制。**必然出现插入异常、删除异常，以及可能出现数据冗余**（数据冗余要看合并的表是否是1对N或N对M关系）、更新异常。下面我们分开详细说明：

另外如果一个表被合并到多个表了，所有的问题是同理的存在的，并且问题被扩大的。尤其是更新，需要更多表的更改，冗余度也更大。当然不是0冗余就是好的设计。那么什么时候合并，什么时候必须要拆分，判断的核心标准就是看**是否会产生插入异常或者删除异常**(说白了就是没法写入，删除会连带其他数据丢失)。有的时候为了效率减少表关联是可以忽略更新异常和冗余问题的。当然有的时候你无法判断是否识别除了所有的实体，那么也可以通过范式来帮助判断！！！

1. 插入异常（无法写入）：因为多表合为一表，当其中一种表没有数据且又是主键部分的组成部分的时候是无法写数据的（如果不是主键的组成部分，主键当前没有数据的时候也是没有办法插入的），如果是主键部分有数据，那么另一个数据不存在的情况就会存在大量的NULL。比如N对M关系如下：

   ```
   (学号，姓名，年龄，课程名称，成绩，学分)，关键字为组合关键字(学号，课程名称)

   假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有"学号"关键字，课程名称和学分也无法记录入数据库。
   ```

2. 删除异常（完全删除一个合并表数据导致另一部分数据被迫完全清除）：也是因为多表合一。其中一个相关数据要全删除会连带另一个数据的删除。如果我们以上面实例为例，如果只有一个学生选了A课程，删除了该学生会导致A课程没了。

  ```
   (学号，姓名，年龄，课程名称，成绩，学分)，关键字为组合关键字(学号，课程名称)

   假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。导致你无法查到课程信息

   ```

3. 数据冗余，如果两表不是1对1关系，必然会冗余关系为一的那一方，要不然多的一方数据会无法存入。
   ```
   (学号，姓名，年龄，课程名称，成绩，学分)，关键字为组合关键字(学号，课程名称)
   如果想存入多个课程的数据，学号、姓名、年龄等学生的基本信息就会需要冗余
   ```

4. 更新异常。有了冗余必然对重复的数据的更新是多次更改，还拿第一个实例来说，如果课程名换了，那么更改的数据量和选择的学生量是正相关的。
   ```
   (学号，姓名，年龄，课程名称，成绩，学分)，关键字为组合关键字(学号，课程名称)
   如果有1个课程10个学生都选了，那么你的更改一个课程名必须更改10次
   ```


## 第一范式(1NF)

**单一属性的，不可再分!!!**

## 第二范式(2NF)

**对主键的完全依赖**,消除对主键的部分依赖!!!

假定选课关系表为SelectCourse(学号，姓名，年龄，课程名称，成绩，学分)，关键字为组合关键字(学号，课程名称)

这个数据库表不满足第二范式，因为存在如下决定关系：

- (课程名称) → (学分)
- (学号) → (姓名，年龄)

因为课程和学生是多对多的关系，所以数据冗余、更新删除插入异常是存在的。如果改为如下三个表就避免了

- 学生表：Student(学号,姓名，年龄)；
- 课程表：Course(课程名称，学分)；
- 选课关系表：SelectCourse(学号，课程名称，成绩)。

## 第三范式（3NF）

**只消除非主属性对主属性的传递依赖**，消除没有直接依赖于第一范式和第二范式形成主键的非主键列。也就是说主键必然能直接导出非主键数据，即不存在“关键字段 → 非关键字段x → 非关键字段y”。如下示例：

学生关系表：Student(学号，姓名，年龄，所在学院，学院地点，学院电话)

学号并不能直接唯一选出“学院地点”，如果学生换了学院择学院地点也就变化了。所以并不是直接关系。实际的直接关系是(所在学院) → (学院地点，学院电话)。

我们很容易看到学生表里添加了学院表，那么学生关系表完全影响学院表数据的，学院表数据会在学生关系表中冗余，并有更新异常、插入异常和删除异常

## BCNF

**取消主属性的相互循环依赖**，这个范式是考察主属性之间是否有依赖关系。所以说BCNF实际上是在第三范式的基础上，进一步消除了主属性的传递依赖。**简单判断就是看否有多个候选关键字（主键）**。

要了解 BCNF 范式，那么先看这样一个问题：

某公司有若干个仓库；每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。

关系模式 仓库（仓库名，管理员，物品名，数量）

这个数据库表中存在如下决定关系：(仓库ID, 存储物品ID) →(管理员ID, 数量)   　(管理员ID, 存储物品ID) → (仓库ID, 数量)所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是候选关键字。产生了(仓库ID) → (管理员ID)  (管理员ID) → (仓库ID) 的循环依赖，以(仓库ID, 存储物品ID)为Key说明产生的问题如下：

1. 插入异常：新增加一个仓库，但尚未存放任何物品，不可以为该仓库指派管理员。因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
2. 删除异常：某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来仓库本身与管理员的信息也被随之删除了。
3. 更新异常：某仓库更换了管理员，这个仓库有几条物品存放记录，就要修改多少次管理员信息。

解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。变为如下两个表。

仓库（仓库名，管理员）

库存（仓库名，物品名，数量）

如果主键是单值，那么符合第三范式自然也就符合BCNF范式。

# 第四范式（4NF）

解决多值依赖问题，因为该问题也会导致插入、删除等问题。

这个范式核心是解决和主键无关的部分的重复问题，即2 3范式已经划分完了，还能从数据中看到明显的冗余，那么就可以通过该范式看下是否存在可能的表合并。因为一旦出现表合并必然会出现插入问题、删除问题；可能出现更新问题！！

多值依赖：  设R(U)是一个属性集合U上的一个关系模式，X, Y, 和Z是U的子集，并且Z=U-X-Y，多值依赖X->->Y成立当且仅当对R的任一个关系r，r在(X,Z)上的每个值对应一组Y的值，这组值仅仅决定于X值而与Z值无关。

若X->->Y，而Z=空集，则称X->->Y为**平凡的多值依赖**。否则，称X->->Y为**非平凡的多值依赖**。

可以看出，如果把上面的一组改为一个，那么多值依赖就变成了函数依赖。当然一个值组成的组也是组，所以说，函数依赖是多值依赖的特殊情况。

那么处理的时候就可以将XZ做成一张表， XY做成一张表。所以最简单的判断方法是看哪些列组合后能对应出多个Y，然后看组合列是否只有一个影响因素即可。

如下示例：

产品(C) | 代理商(A) | 工厂(F)
| ----- | ---- | ----- | 
Car     |  A1  |   F1
Car 	|  A1  |   F2
Bus     |  A2  |   F2

这里“产品(C，A)→→工厂(F)”，产生的多值依赖关系如下：

产品(C) | 代理商(A) | 工厂(F)
| ----- | ---- | ----- | 
Car     |  A1  |   F1
Car 	|  A1  |   F2

表中，U = C+F+A，（C,A）确定一组F,但是这组F其实与A无关，仅由C确定，所以(C,A)->->F。又因为A不是空集，所以(C,A)->->F为**非平凡多值依赖**。去掉

为了消除多值依赖，分解表如下：

产品-经销商关系表  （产品 	供应商）

产品生产关系表 （产品 	工厂）